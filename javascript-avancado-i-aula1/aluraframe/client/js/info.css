Temos a seguinte sequência de números:

let numeros = [3,2,11,20,8,7];
Sua tarefa: criar uma nova lista com a mesma quantidade de números, mas cada elemento da nova lista deve ter seu valor dobrado quando for ímpar.

ATENÇÃO: a lista numeros não pode ser alterada! Você pode resolver do jeito que desejar, o mais importante é o resultado.

VER OPINIÃO DO INSTRUTOR
Opinião do instrutor

Tenho certeza que pode ter passado em sua cabeça zilhões de formas de resolver o problema passado, inclusive fica muito difícil para mim mapeá-las todas aqui. Porém, que tal usarmos uma maneira não funcional para resolver esse problema?

let numeros = [3,2,11,20,8,7];
let novosNumeros = [];

numeros.forEach(item => {

    if(item % 2  != 0) {
        novosNumeros.push(item * 2);
    } else {
        novosNumeros.push(item);
    }
});
console.log(novosNumeros);
Para sabermos se um número é par ou não, usamos item % 2, que retorna o resto da divisão por 2. Se for 0, é porque o número é par, se não for, é ímpar. Aliás, nem precisamos fazer item % 2 != 0, podemos simplesmente fazer item % 2. Se o resultado for 0, este número é considerado falso pelo JavaScript. Alterando nosso código:

let numeros = [3,2,11,20,8,7];
let novosNumeros = [];

numeros.forEach(item => {

    if(item % 2) { // só entra no IF se o resultado for diferente de zero
        novosNumeros.push(item * 2);
    } else {
        novosNumeros.push(item);
    }
});

console.log(novosNumeros);
Apesar de funcionar e termos usado o forEach, nossa solução não é uma solução funcional. Alterando nosso código e exaurindo o poder da programação funcional:

let numeros = [3,2,11,20,8,7];
let novosNumeros = numeros.map(item =>  item % 2 ? item * 2 : item);
console.log(novosNumeros);
Veja que usamos um if ternário para decidir se retornamos o item multiplicado por 2 ou o item em si. Um outro ponto importante é o seguinte: 0 é considerado falso em JavaScript e qualquer número diferente de 0 é considerado verdadeiro. Então, quando fazemos item % 2, se o resultado for 0, é porque o item é divisível por dois, ou seja, é par. Como 0 é falso, ele retornará o item sem qualquer modificação. Agora, se o resto da divisão de item % 2 for diferente de zero, é porque é impar. Como o resultado é diferente de zero, será verdadeiro e o que vem depois do interrogação será processado, no caso, item vezes dois.

Outra maneira de se conseguir o mesmo resultado, sem entretanto utilizar o operador ternário, é:

let numeros = [3,2,11,20,8,7];
let novosNumeros = numeros.map((item)=> (item%2 +1 ) * item);
console.log(novosNumeros);
Quando fazemos o módulo de dois um número par, o que sobra é 0, somando-se 1, e depois multiplicando pelo item, obtemos o mesmo item. Quando o número é impar, o modulo obtido é um, o qual incrementado dá 2.


Você já deve ter ouvido falar em somatórios. O somatório de uma lista de números é a soma de todos os números daquela lista, como por exemplo:

let numeros = [1, 2, 3, 4]; // Somatório = 1 + 2 + 3 + 4 = 10
Um exemplo de função que nos retorne o somatório de um array de números poderia ser assim:

function somatorio(array) {

    var resultado = 0;
    for(let i = 0; i < array.length; i++){
        resultado = array[i] + resultado;
    }

    return resultado;
}
A mesma coisa usando forEach:

function somatorio(array) {
    let resultado = 0;
    array.forEach(item => resultado+= item);
    return resultado;
}
Existe um outro conceito matemático conhecido como produtório, que é análogo ao somatório, só que ao invés de somarmos os números , nós os multiplicamos. Por exemplo:

var numeros = [1, 2, 3, 4]; // Produtório = 1 * 2 * 3 * 4 = 24
Juntando este seu novo conhecimento matemático com o conhecimento de JavaScript adquirido neste capítulo, qual das funções abaixo nos retorna o produtório de um array de números corretamente, usando a função reduce?

Alternativa correta
let numeros = [1, 2, 3, 4];
let resultado = numeros.reduce((total, num) {
    return num * num;
}, 1);

Alternativa correta
let numeros = [1, 2, 3, 4];
let resultado = numeros.reduce((total, num) {
    return total * (total * num);
}, 1);

Alternativa correta
let numeros = [1, 2, 3, 4];
let resultado = numeros.reduce(function(total, num) {
    return total * num;
}, 1);

Isso aí! Essa é a opção correta!

Alternativa correta
let numeros = [1, 2, 3, 4];
let resultado = numeros.reduce(function(total, num) {
    return total * num;
}, 0);

O segundo parâmetro da função reduce, que é o valor inicial, deveria ser 1.

A função reduce recebe dois parâmetros: uma função e um valor inicial. Na função interna ao reduce, o primeiro parâmetro é o valor da última iteração, que neste caso é o total. O segundo parâmetro é o valor da iteração atual, neste caso o novo número que queremos multiplicar.

O reduce executa sua função interna a cada iteração, então no nosso caso ele multiplica o valor anterior (total) pelo valor da iteração atual (num). Como o produtório é a multiplicação de uma sequência de números, no nosso caso o que está acontecendo é o seguinte:

Supondo o array:

var numeros = [1, 2, 3, 4];
O total se inicia com o valor 1*, *definido pelo segundo parâmetro da função reduce.

É feita a primeira iteração, pegando o primeiro valor do array (1) :

return total * num; // Leia-se: return 1 * 1 e coloque este valor em total.
Na segunda iteração, com o segundo valor do array (2):

return total * num; // Leia-se return 1 * 2 e coloque este valor em total, que agora vale 2;
Na terceira iteração, com o segundo valor do array (3):

return total * num; // Leia-se return 2 * 3 e coloque este valor em total, que agora vale 6;
Na segunda iteração, com o segundo valor do array (4):

return total * num; // Leia-se return 6 * 4 e coloque este valor em total, que agora vale 24;
E no final ele devolve para nós o valor 24 , que é o valor esperado do produtório!

Parabéns, você acertou!
DISCUTIR NO FORUM
PRÓX